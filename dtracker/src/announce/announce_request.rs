use std::{collections::HashMap, num::ParseIntError, str::FromStr};

use super::announce_request_error::AnnounceRequestError;
use crate::tracker_peer::event::PeerEvent;
use url_encoder::url_encoder::decode;

/// Struct representing the announce request to a tracker.
///
/// # Fields
/// * `info_hash`: urlencoded 20-byte SHA1 hash of the value of the info key from the Metainfo file.
/// * `peer_id`: urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup.
/// * `port`: The port number the client is listening on.
/// * `uploaded`: The total amount of data uploaded by the client, in bytes.
/// * `downloaded`: The total amount of data downloaded by the client, in bytes.
/// * `left`: The total size of the file, in bytes, that the client still has to download.
/// * `compact`: If true, the response will be in compact format.
/// * `no_peer_id`: If true, the response will not include the peer id.
/// * `event`: *(Optional)* The event that the client is reporting. Possible values are:
///     * `started`: The client has just started.
///     * `stopped`: The client has just stopped.
///     * `completed`: The client has just successfully downloaded the file.
/// * `ip`: *(Optional)* The IP address of the client. If not present, the IP address of the client will be determined automatically.
/// * `numwant`: The number of peers that the client would like to receive in the response. If absent, the client requests a default number of peers.
/// * `key`: *(Optional)* The key used to identify the client. If absent, the client will be identified by its peer id.
/// * `trackerid`: *(Optional)* The id of the tracker. If absent, the tracker will be identified by its IP address.
#[derive(Debug, Clone)]
pub struct AnnounceRequest {
    pub info_hash: [u8; 20],
    pub peer_id: [u8; 20],
    pub port: u16,
    pub uploaded: u64,
    pub downloaded: u64,
    pub left: u64,
    pub compact: bool,
    pub no_peer_id: bool,
    pub event: Option<PeerEvent>,
    pub ip: Option<String>,
    pub numwant: u32,
    pub key: Option<String>,
    pub tracker_id: Option<String>,
}

const DEFAULT_NUMWANT: &str = "50";

impl AnnounceRequest {
    /// Creates a new AnnounceRequest from a HashMap containing the query parameters of the announce request.
    ///
    /// If the request is invalid, an error is returned.
    pub fn new_from(query_params: HashMap<String, String>) -> Result<Self, AnnounceRequestError> {
        // Obligatory params:
        let info_hash = Self::get_info_hash(&query_params)?;
        let peer_id = Self::get_peer_id(&query_params)?;
        let port = Self::get_port(&query_params)?;
        let uploaded = Self::get_uploaded(&query_params)?;
        let downloaded = Self::get_downloaded(&query_params)?;
        let left = Self::get_left(&query_params)?;

        // Optional and default params:
        let compact = Self::get_compact(&query_params);
        let no_peer_id = Self::get_no_peer_id(&query_params);
        let event = Self::get_event(&query_params)?;
        let ip = Self::get_ip(&query_params);
        let numwant = Self::get_numwant(&query_params)?;
        let key = Self::get_key(&query_params);
        let tracker_id = Self::get_tracker_id(&query_params);

        Ok(Self {
            info_hash,
            peer_id,
            port,
            uploaded,
            downloaded,
            left,
            compact,
            no_peer_id,
            event,
            ip,
            numwant,
            key,
            tracker_id,
        })
    }

    fn get_info_hash(
        query_params_map: &HashMap<String, String>,
    ) -> Result<[u8; 20], AnnounceRequestError> {
        let info_hash = query_params_map.get("info_hash").map_or_else(
            || Err(AnnounceRequestError::InvalidInfoHash),
            |i| {
                Self::decode_hex(&decode(i))
                    .map_err(|_| AnnounceRequestError::InvalidInfoHash)?
                    .try_into()
                    .map_err(|_| AnnounceRequestError::InvalidInfoHash)
            },
        )?;
        Ok(info_hash)
    }

    fn decode_hex(s: &str) -> Result<Vec<u8>, ParseIntError> {
        (0..s.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&s[i..i + 2], 16))
            .collect()
    }

    fn get_peer_id(
        query_params_map: &HashMap<String, String>,
    ) -> Result<[u8; 20], AnnounceRequestError> {
        let peer_id = query_params_map.get("peer_id").map_or_else(
            || Err(AnnounceRequestError::InvalidPeerId),
            |i| {
                Self::decode_hex(&decode(i))
                    .map_err(|_| AnnounceRequestError::InvalidPeerId)?
                    .try_into()
                    .map_err(|_| AnnounceRequestError::InvalidPeerId)
            },
        )?;
        Ok(peer_id)
    }

    fn get_port(query_params_map: &HashMap<String, String>) -> Result<u16, AnnounceRequestError> {
        let port = query_params_map.get("port").map_or_else(
            || Err(AnnounceRequestError::InvalidPort),
            |p| {
                p.parse::<u16>()
                    .map_err(|_| AnnounceRequestError::InvalidPort)
            },
        )?;
        Ok(port)
    }

    fn get_uploaded(
        query_params_map: &HashMap<String, String>,
    ) -> Result<u64, AnnounceRequestError> {
        let uploaded = query_params_map.get("uploaded").map_or_else(
            || Err(AnnounceRequestError::InvalidUploaded),
            |u| {
                u.parse::<u64>()
                    .map_err(|_| AnnounceRequestError::InvalidUploaded)
            },
        )?;
        Ok(uploaded)
    }

    fn get_downloaded(
        query_params_map: &HashMap<String, String>,
    ) -> Result<u64, AnnounceRequestError> {
        let downloaded = query_params_map.get("downloaded").map_or_else(
            || Err(AnnounceRequestError::InvalidDownloaded),
            |d| {
                d.parse::<u64>()
                    .map_err(|_| AnnounceRequestError::InvalidDownloaded)
            },
        )?;
        Ok(downloaded)
    }

    fn get_left(query_params_map: &HashMap<String, String>) -> Result<u64, AnnounceRequestError> {
        let left = query_params_map.get("left").map_or_else(
            || Err(AnnounceRequestError::InvalidLeft),
            |l| {
                l.parse::<u64>()
                    .map_err(|_| AnnounceRequestError::InvalidLeft)
            },
        )?;
        Ok(left)
    }

    fn get_compact(query_params_map: &HashMap<String, String>) -> bool {
        query_params_map.get("compact").unwrap_or(&"0".to_string()) == "1"
    }

    fn get_no_peer_id(query_params_map: &HashMap<String, String>) -> bool {
        query_params_map
            .get("no_peer_id")
            .unwrap_or(&"0".to_string())
            == "1"
    }

    fn get_event(
        query_params_map: &HashMap<String, String>,
    ) -> Result<Option<PeerEvent>, AnnounceRequestError> {
        match query_params_map
            .get("event")
            .map(|e| PeerEvent::from_str(e).ok())
        {
            Some(ev) => match ev {
                Some(ev) => Ok(Some(ev)),
                None => Err(AnnounceRequestError::InvalidEvent),
            },
            None => Ok(None),
        }
    }

    fn get_ip(query_params_map: &HashMap<String, String>) -> Option<String> {
        query_params_map.get("ip").map(|ip| ip.to_string())
    }

    fn get_numwant(
        query_params_map: &HashMap<String, String>,
    ) -> Result<u32, AnnounceRequestError> {
        query_params_map
            .get("numwant")
            .unwrap_or(&DEFAULT_NUMWANT.to_string())
            .parse::<u32>()
            .map_err(|_| AnnounceRequestError::InvalidNumwant)
    }

    fn get_key(query_params_map: &HashMap<String, String>) -> Option<String> {
        query_params_map.get("key").map(|s| s.to_string())
    }

    fn get_tracker_id(query_params_map: &HashMap<String, String>) -> Option<String> {
        query_params_map.get("tracker_id").map(|s| s.to_string())
    }
}
